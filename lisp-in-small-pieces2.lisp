(in-package :lisp)

;;;;evaluation -> dynamic, no closures
(defun %eval (form env)
  (if (atom form)
      (if (symbolp form)
	  (lookup form env)	  
	  form)
      (case (car form)
	(quote (car (cdr form)))
	(if (if (truep (%eval (car (cdr form))
			      env))
		(%eval (car (cdr (cdr form)))
		       env)
 		(%eval (car (cdr (cdr (cdr form))))
		       env)))
	(progn (evaluate-progn (cdr form)
			       env))
	(setq (update! (car (cdr form))
		       env
		       (%eval (car (cdr (cdr form)))
			      env)))
	(lambda (make-function
		 (car (cdr form))
		 (cdr (cdr form))
		 env))
	(otherwise (%apply (%eval (car form) env)
			   (evlis (cdr form) env))))))
(defun evlis (params env)
  (if (consp params)
      (let ((arg0 (%eval (car params) env)))
	(cons arg0
	      (evlis (cdr params) env)))
      nil))
(defun evaluate-progn (body env)
  (if (consp body)
      (if (consp (cdr body))
	  (progn (%eval (car body)
			env)
		 (evaluate-progn (cdr body)
				 env))
	  (%eval (car body) env))
      *empty-progn*))
